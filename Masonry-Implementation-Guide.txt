HKI News Feed — Masonry Implementation Guide

(Next.js 13/14 + TypeScript + Supabase)

⸻

0 . Why Masonry for HKI?
	•	Variable-height story cards (image + headline + snippet + meta) waste space in a fixed-row grid.
	•	Masonry packs cards top-to-bottom in the shortest column, maximising density and discovery.
	•	Users already recognise the pattern from Taobao, Pinterest and Instagram — zero learning curve.

⸻

1 . Tech-stack decisions

Layer	Choice	Rationale
Layout engine	masonry-layout @ 4.2.2 (a.k.a. Masonry.js)	Battle-tested, 30 KB gzipped, no React runtime dependency. Last release 4.2.2  ￼.
Image load synchroniser	imagesloaded @ 5	Ensures Masonry recalculates after each image height is known  ￼.
Progressive enhancement	Ship native CSS Grid masonry first; dynamically load Masonry.js only for browsers that lack support.	
Framework	Next.js App Router ("use client" component)	HKI already uses Next.js; hydration handled automatically.
Data	Stream paginated articles from Supabase via RLS-safe RPC.	
Scroll	react-intersection-observer for infinite-scroll triggers.	
Optional virtualisation	@tanstack/react-virtual when feed > 1 k cards to keep DOM ≤ ~200 nodes.	


⸻

2 . Install packages

pnpm add masonry-layout imagesloaded
pnpm add -D @types/masonry-layout @types/imagesloaded   # TS typings


⸻

3 . Markup & styles

/* globals.css */
.feed {
  /* Try the new native masonry first */
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
  grid-auto-rows: masonry;      /* browsers that support it */
  gap: 12px;
}

.card img      { width: 100%; aspect-ratio: 16/9; object-fit: cover; }
.card h3       { font: 600 16px/1.3 Helvetica, sans-serif; margin: 8px 0 4px; }
.card p        { font: 14px/1.4 Helvetica, sans-serif; color: #555; }

Browsers that don’t recognise grid-auto-rows: masonry will render a normal grid — we’ll intercept those in JS and apply Masonry.js.

⸻

4 . Feed component (client-side)

// app/(hki)/components/NewsFeed.tsx
"use client";
import { useEffect, useRef, useState } from "react";
import { useInView } from "react-intersection-observer";
import type { Article } from "@/types";

export default function NewsFeed({ initial }: { initial: Article[] }) {
  const [items, setItems] = useState(initial);
  const feedRef      = useRef<HTMLDivElement>(null);
  const masonryRef   = useRef<any>(null);      // Masonry instance
  const { ref: sentinelRef, inView } = useInView({ rootMargin: "600px" });

  /* 1️⃣  Load Masonry *only if* browser lacks native masonry */
  useEffect(() => {
    if (!feedRef.current) return;
    const supportsNative = CSS.supports("grid-template-rows", "masonry");
    if (supportsNative) return; // nothing to do

    (async () => {
      const [{ default: Masonry }, imagesLoaded] = await Promise.all([
        import("masonry-layout"),                 // dynamic import → CSR only
        import("imagesloaded")
      ]);

      masonryRef.current = new Masonry(feedRef.current!, {
        itemSelector : ".card",
        columnWidth  : ".card",        // width is controlled by CSS grid
        percentPosition: true
      });

      // re-layout each time an image finishes loading
      imagesLoaded(feedRef.current!, () => masonryRef.current.layout());
    })();
  }, []);

  /* 2️⃣  Infinite-scroll when sentinel enters viewport */
  useEffect(() => {
    if (!inView) return;
    fetch(`/api/articles?after=${items[items.length - 1]?.id}`)
      .then(r => r.json())
      .then((next: Article[]) => setItems(prev => [...prev, ...next]));
  }, [inView]);

  return (
    <>
      <section ref={feedRef} className="feed">
        {items.map(a => (
          <article key={a.id} className="card">
            <img src={a.image_url} alt={a.headline} loading="lazy" />
            <h3>{a.headline}</h3>
            <p>{a.snippet}</p>
          </article>
        ))}
      </section>
      <div ref={sentinelRef} />   {/*  intersection-observer target */}
    </>
  );
}

Dynamic import() prevents Masonry from being bundled into the server build, eliminating hydration mismatches — a common Next.js pitfall  ￼.

⸻

5 . Responsive breakpoints

Masonry.js respects whatever width you give each .card.
For more granular control, add per-breakpoint column counts:

@media (min-width: 600px) { .feed { grid-template-columns: repeat(2,1fr); } }
@media (min-width: 960px) { .feed { grid-template-columns: repeat(3,1fr); } }
@media (min-width: 1280px){ .feed { grid-template-columns: repeat(4,1fr); } }

Because the CSS drives the width, Masonry’s columnWidth: '.card' auto-adapts — no JS resize listener needed.

⸻

6 . Performance & UX checklist

Concern	Action
Layout thrash	Pre-declare image aspect ratio (via aspect-ratio or width/height attrs) so Masonry recalculates less often.
Long feeds	Once feed length > 1 k, virtualise off-screen cards (@tanstack/react-virtual) to keep DOM light.
CLS / LCP	Use next/image or <img loading="lazy">; delay heavier 3rd-party embeds until card enters viewport.
Accessibility	Ensure DOM order = visual order: Masonry.js already repositions visually only (absolutely positioned), so screen-readers follow source order. Provide aria-labels on cards.
SEO SSR	Card markup is rendered server-side; Masonry enhances on the client, so crawlers still see full article list.
Offline caching	Prefetch next page JSON via <link rel="prefetch"> once user scrolls > 70 %.


⸻

7 . Deploy on Vercel
	1.	vercel env add your Supabase keys.
	2.	Ensure imagesloaded and masonry-layout are client-only ("browser" field in package.json not needed thanks to dynamic import).
	3.	Enable Edge Functions for /api/articles if you need sub-100 ms pagination.

Deployment is then git push → Build → CDN-backed.

⸻

8 . Future-proofing
	•	Keep track of CSS Grid level 3: once Safari & Firefox ship grid-auto-rows: masonry, you can drop Masonry.js entirely and delete ~30 KB JS. Chromium already supports it behind a flag  ￼.
	•	If HKI roadmap includes drag-to-reorder or live filtering, swap Masonry.js for Muuri, which adds those interactions (60 KB) at the cost of more JS.

⸻

Recap
	1.	Progressive enhancement: native CSS Masonry first, JS fallback only when needed.
	2.	Dynamic import in a "use client" component eliminates SSR headaches.
	3.	imagesLoaded ensures height-aware relayout.
	4.	IntersectionObserver drives infinite scroll; virtualise when feed grows.

Follow this blueprint and HKI’s aggregated news cards will render densely, scroll smoothly, and stay SEO-friendly — all while adding only a few kilobytes of critical JS to the first paint.


After installing, load it only on the client:
if (!CSS.supports('grid-template-rows', 'masonry')) {
  const [{ default: Masonry }, imagesLoaded] = await Promise.all([
    import('masonry-layout'),
    import('imagesloaded')
  ]);
  /* …init Masonry here… */
}

That keeps the package out of your server bundle and avoids hydration mismatches in Next.js.
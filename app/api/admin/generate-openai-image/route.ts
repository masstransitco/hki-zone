export const runtime = 'nodejs';

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import OpenAI from 'openai';
import { toFile } from 'openai/uploads';
import sharp from 'sharp';
import { randomUUID } from 'crypto';
import { autoProcessArticleImage } from '@/lib/image-processor';

// ---------- CONFIG ----------
const OPENAI_TIMEOUT_MS = 300_000; // allow long image jobs
const DEFAULT_SIZE = '1792x1024'; // 16:9 aspect ratio for DALL-E 3
const BUCKET = 'article-images';
const PREFIX = 'articles';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;
const supabase = createClient(supabaseUrl, supabaseKey);

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
  timeout: OPENAI_TIMEOUT_MS,
});

// Use GPT-4 to generate contextual DALL-E prompt based on article content
async function generateContextualPrompt(article: any): Promise<string> {
  const title = article?.title || ''
  const content = article?.content || ''
  const summary = article?.summary || ''
  const category = article?.category || ''
  
  const systemPrompt = `You are a photo editor creating DALL-E 3 prompts for news articles. Generate prompts that create professional, editorial-quality images while STRICTLY avoiding content that triggers DALL-E's safety filters.

CRITICAL SAFETY RULES (MUST FOLLOW):
- NO TEXT: Never request any text, signage, words, letters, numbers, or characters in the image
- NO BRANDS: Never mention company names, brand names, logos, trademarks, or branded products
- NO SPECIFIC PEOPLE: Never describe ages, ethnicities, or physical features
- Use ONLY generic terms: "people", "person", "crowd", "professionals", "residents", "workers"
- Focus on ENVIRONMENTS, ARCHITECTURE, and ABSTRACT CONCEPTS rather than people

TEXT & BRAND AVOIDANCE (ESSENTIAL):
- Always explicitly add "no text, no signage, no logos, no brands" to every prompt
- Instead of "shop signs" say "storefronts without text"
- Instead of "branded vehicles" say "generic vehicles"
- Instead of "company buildings" say "office buildings"
- Replace any branded items with generic equivalents

SAFE PROMPT STRUCTURE:
1. Start with the LOCATION or SETTING (buildings, landscapes, cityscapes)
2. Add ATMOSPHERIC elements (weather, time of day, lighting)
3. Include ACTIVITY if needed (using generic terms like "busy street scene")
4. ALWAYS end with: "no text, no signage, no logos, no brands, professional editorial photography"

HONG KONG CONTEXT (safe elements):
- Locations: Victoria Harbour, Central district skyline, street markets, MTR stations
- Architecture: modern skyscrapers, traditional shophouses, public housing estates
- Atmosphere: urban density, storefronts without text, busy streets, harbor views
- Vehicles: generic taxis, buses without branding, anonymous vehicles

AVOID COMPLETELY:
- Any form of text, writing, or signage
- Brand names, company names, product names
- Age descriptors (elderly, old, young, child, teen, senior, etc.)
- Specific demographics or ethnicities
- Physical descriptions of people
- Medical or health-related imagery
- Any potentially sensitive social issues

OUTPUT:
- Keep prompts under 100 words
- MUST include "no text, no signage, no logos, no brands" in every prompt
- Focus on environment and atmosphere
- Return only the prompt text`

  const userPrompt = `Create a DALL-E prompt for this Hong Kong news article:

Title: ${title}
Category: ${category}
Summary: ${summary}
Content: ${content.slice(0, 1500)}

Generate a prompt that will create a professional news photograph that captures the essence of this story with authentic Hong Kong context.`

  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt }
      ],
      max_tokens: 500,
      temperature: 0.7
    })

    const prompt = response.choices[0]?.message?.content?.trim()
    if (!prompt) {
      throw new Error('No prompt generated by GPT-4')
    }

    return prompt
  } catch (error) {
    console.error('Error generating contextual prompt:', error)
    // Fallback to a safer category-based prompt
    const safeCategoryPrompts: Record<string, string> = {
      'Politics': 'Hong Kong government buildings and administrative district, modern architecture, professional atmosphere',
      'Business': 'Hong Kong financial district skyline, Central business towers, commercial buildings without signage',
      'Technology': 'Modern Hong Kong tech hub, contemporary office buildings, clean minimalist architecture',
      'Health': 'Modern medical facility exterior in Hong Kong, clean architecture, professional healthcare environment',
      'Education': 'Hong Kong university campus buildings, modern educational architecture, academic environment',
      'Sports': 'Hong Kong sports facility, stadium architecture, athletic venue exterior',
      'Entertainment': 'Hong Kong cultural district, performance venue architecture, creative spaces',
      'Crime': 'Hong Kong justice building exterior, courthouse architecture, legal district',
      'Environment': 'Hong Kong green spaces and sustainable architecture, urban nature, eco-friendly buildings',
      'International': 'Hong Kong international commerce buildings, trade center architecture, global business district'
    }
    
    // Try to use category-specific fallback, or default to safe Hong Kong scene
    const categoryFallback = category ? safeCategoryPrompts[category] : null
    
    if (categoryFallback) {
      return `${categoryFallback}, no text, no signage, no logos, no brands, documentary photography style, natural lighting, professional editorial photography`
    }
    
    // Ultimate fallback - safe generic Hong Kong scene
    return `Hong Kong urban district, modern architecture mixed with traditional buildings, busy street atmosphere, no text, no signage, no logos, no brands, professional documentary photography style, editorial quality, natural lighting`
  }
}

// ---------- HELPERS ----------
async function fetchAsBuffer(url: string, abortMs = 60_000): Promise<Buffer> {
  const ac = new AbortController();
  const t = setTimeout(() => ac.abort(), abortMs);
  try {
    const res = await fetch(url, { signal: ac.signal });
    if (!res.ok) throw new Error(`Failed to fetch image: ${res.status} ${res.statusText}`);
    const arrayBuf = await res.arrayBuffer();
    return Buffer.from(arrayBuf);
  } finally {
    clearTimeout(t);
  }
}

async function preprocessImageToPng(input: Buffer, maxDim = 2048): Promise<Buffer> {
  // Keeps within 2048px limit to reduce transfer & processing time
  return sharp(input)
    .resize({ width: maxDim, height: maxDim, fit: 'inside', withoutEnlargement: true })
    .png()
    .toBuffer();
}

async function uploadToSupabase(buffer: Buffer, articleId: string, contentType = 'image/png') {
  const fileName = `gpt4-dalle3-${articleId}-${Date.now()}.png`;
  const storagePath = `${PREFIX}/${articleId}/${fileName}`;
  const { error } = await supabase.storage.from(BUCKET).upload(storagePath, buffer, {
    contentType,
    upsert: false,
  });
  if (error) throw error;
  const { data } = supabase.storage.from(BUCKET).getPublicUrl(storagePath);
  return { storagePath, publicUrl: data.publicUrl };
}

async function runWithRetry<T>(fn: () => Promise<T>, tries = 2): Promise<T> {
  let lastErr: any;
  for (let i = 0; i < tries; i++) {
    try {
      return await fn();
    } catch (e: any) {
      lastErr = e;
      // Retry only on transient connection failures
      const msg = (e?.message || '').toLowerCase();
      if (
        !msg.includes('apiconnectionerror') &&
        !msg.includes('und_err_socket') &&
        !msg.includes('socket') &&
        !msg.includes('fetch failed') &&
        !msg.includes('timeout')
      ) {
        break;
      }
      await new Promise((r) => setTimeout(r, 1000 * (i + 1) + Math.floor(Math.random() * 500)));
    }
  }
  throw lastErr;
}

// ---------- ROUTE ----------
export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const { imageUrl, articleId } = body;

    if (!imageUrl || !articleId) {
      return NextResponse.json(
        { error: 'Image URL and Article ID are required' },
        { status: 400 }
      );
    }

    // Fetch article details for context
    console.log('Fetching article details...');
    const { data: article, error: fetchError } = await supabase
      .from('articles')
      .select('id, title, summary, category, content')
      .eq('id', articleId)
      .single();

    if (fetchError || !article) {
      console.warn('Could not fetch article for context:', fetchError);
    }

    // Step 1: Use GPT-4 to generate contextual DALL-E prompt
    console.log('Using GPT-4 to analyze article and generate contextual prompt...');
    const prompt = await generateContextualPrompt(article);
    console.log('GPT-4 generated DALL-E prompt:', prompt);

    // Step 2: Use DALL-E 3 to generate image from GPT-4 prompt
    console.log('Calling DALL-E 3 API with GPT-4 generated prompt...');
    const res = await runWithRetry(() =>
      openai.images.generate({
        model: 'dall-e-3',
        prompt,
        size: DEFAULT_SIZE,
        quality: 'hd',
        style: 'natural',
        n: 1
      })
    );

    const generatedImageUrl = res.data?.[0]?.url;
    if (!generatedImageUrl) throw new Error('No image returned from DALL-E 3 generation');
    
    // Download the generated image
    const genBuffer = await fetchAsBuffer(generatedImageUrl);

    // Upload to Supabase
    console.log('Uploading generated image to Supabase...');
    const { publicUrl, storagePath } = await uploadToSupabase(genBuffer, articleId, 'image/png');

    // Update article with new image URL
    const { error: updateError } = await supabase
      .from('articles')
      .update({ image_url: publicUrl })
      .eq('id', articleId);

    if (updateError) {
      console.error('Article update error:', updateError);
      throw new Error(`Failed to update article: ${updateError.message}`);
    }

    console.log('Article updated successfully with DALL-E 3 generated image');

    // Auto-process the OpenAI-generated image for social media previews
    // Use forceReprocess=true to ensure we process the new OpenAI image even if metadata exists
    autoProcessArticleImage(articleId, publicUrl, 'articles', true).catch(error => {
      console.error(`Failed to process OpenAI-generated image for article ${articleId}:`, error)
    })

    return NextResponse.json({
      success: true,
      imageUrl: publicUrl,
      storagePath,
      articleId,
      message: 'Professional editorial image generated successfully with GPT-4 + DALL-E 3',
    });
  } catch (error: any) {
    console.error('OpenAI image generation error:', error);
    const status = String(error?.message || '').toLowerCase().includes('apiconnectionerror') ? 504 : 500;
    return NextResponse.json(
      { error: error?.message || 'Failed to generate image' },
      { status },
    );
  }
}